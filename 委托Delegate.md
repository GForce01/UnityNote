简而言之，委托delegate本身并不是完整的方法，只是一个方法的容器。
一个经典的委托声明代码如下：
	delegate void MyDelegate();
可以看出，这里定义delegate的方法虽然和定义方法很像，但是它只定义了方法的返回值和参数类型（在这里都是空）却没有定义具体的实现方法。因此，委托是一种抽象方法。

形象一些来形容，想象整个程序是从零开始建立一个工厂，委托相当于 **“流水线”这一个抽象概念**。第一步的委托声明目的是定义一条标准的“流水线”应该有什么基本**特征**：
	delegate int AssemblyLine(int material1, int material 2);

如果想开工，只知道“流水线”是什么是没有用的，因为现在的流水线只存在于想象中，在开工前要先**建立几条真实存在的流水线**。也就是定义委托的**实例化**：
	AssemblyLine firstAssemblyLine;
	AssemblyLine secondAssemblyLine;

现在流水线建立好了，却没有具体的工作任务。委托与直接声明方法最大的不同是它**灵活可变**，直接声明的方法是一条买来的预制机器，一台机器只能干固定一件事，但是流水线可以随时重新组装以**适应不同任务**。因此想要调动流水线，要先给每条流水线**指派具体任务**：
	firstAssemblyLine  += （）